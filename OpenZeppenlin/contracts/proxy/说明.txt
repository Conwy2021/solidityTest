透明代理合约
解决函数名冲突 
单独使用admin调用升级函数，导致admin 不能使用逻辑合约函数。 解决方法是用一个合约充当admin角色。
举个例子，如果逻辑合约的a函数和代理合约的升级函数的选择器相同，那么管理人就会在调用a函数的时候，将代理合约升级成一个黑洞合约，后果不堪设想。
只有admin权限 能更改实现合约地址

uups代理合约
解决函数名冲突
将升级函数写在逻辑合约中，这样如果函数冲突了编译无法通过。避免了函数冲突。
只是把升级函数写在逻辑合约 实际调用还是在代理合约

uups 之前漏洞解析
https://medium.com/immunefi/wormhole-uninitialized-proxy-bugfix-review-90250c41a43a
以下是如何执行假设攻击的分步指南：

攻击者调用initialize()执行合约成为所有者。记住上面的一点，initialize()第一个称它为所有者的人。由于还没有人在实现的上下文中调用过此函数，因此调用有效并使攻击者成为所有者
攻击者部署一个带有selfdestruct()函数的恶意合约
攻击者以所有者身份upgradeToAndCall()调用执行合约，并将其指向恶意自毁合约
在upgradeToAndCall()执行期间，DELEGATECALL使用实施合约（而非代理）的上下文从实施合约调用到恶意自毁合约
SELFDESTRUCT被调用，破坏执行合约
代理合约现在变得无用

uups 之前搞回滚的目的是 查看逻辑合约中是否有更换逻辑合约的代码